{{- if not (.Get "name") -}}
<p>Error: No map name specified. Please specify a map name in the shortcode. Example: \{\{&lt; map name="mapname" &gt;\}\}</p>
{{- else -}}
  {{- $mapConfigName := .Get "name" -}}
  {{- $hugoMapsConfig := index site.Params "hugo-maps" -}}
  {{- $mapparams := index $hugoMapsConfig $mapConfigName -}}

  {{- if not $mapparams -}}
<p>Error: Map name {{- $mapConfigName -}} not found in config. Please check your config file.</p>
  {{- else -}}
    {{- $mapname := md5 now.UnixNano -}}
    {{- $baseparams := (resources.Get "default/mapparams.yaml") | unmarshal -}}
    {{- $defaultparams := index $hugoMapsConfig "default" | default dict -}}
    {{- $mapparams = merge $baseparams $defaultparams $mapparams -}}
    {{- $addressZoom := .Get "address-zoom" | default .Page.Params.addressZoom | default ($mapparams.addressZoom | default "") -}}
    
    {{- /* Build geocode query from configured parameters */ -}}
    {{- $geocodeParams := $mapparams.geocodeParams | default "address" -}}
    {{- $mapAddress := "" -}}
    {{- if reflect.IsMap $geocodeParams -}}
      {{- /* If it's a map/dict, use it as-is (shouldn't happen but just in case) */ -}}
      {{- $mapAddress = index $.Page.Params "address" -}}
    {{- else if reflect.IsSlice $geocodeParams -}}
      {{- /* It's an array of parameter names - combine them */ -}}
      {{- $parts := slice -}}
      {{- range $geocodeParams -}}
        {{- $val := index $.Page.Params . -}}
        {{- if $val -}}
          {{- $parts = $parts | append (printf "%v" $val) -}}
        {{- end -}}
      {{- end -}}
      {{- $mapAddress = delimit $parts ", " -}}
    {{- else -}}
      {{- /* It's a string parameter name */ -}}
      {{- $mapAddress = index $.Page.Params (printf "%v" $geocodeParams) -}}
    {{- end -}}
    {{- /* Allow shortcode override */ -}}
    {{- $mapAddress = .Get "address" | default $mapAddress -}}
    {{- $addressZoom := .Get "address-zoom" | default $.Page.Params.addressZoom | default ($mapparams.addressZoom | default "") -}}

    {{- $mapstyle := dict -}}

    {{- if eq ($mapparams.type | default "remote") "remote" -}}
      {{- $sources := dict "sources" ($mapparams.sources | default dict) -}}
      {{- $mapstyle = resources.Get (printf "map-styles/%s.json" ($mapparams.style | default "osm-bright")) | unmarshal -}}
      {{- $mapstyle = merge $mapstyle $sources -}}
    {{- end -}}

    <script src='https://cdn.jsdelivr.net/npm/maplibre-gl@5.17.0/dist/maplibre-gl.js'></script>
    <link href='https://cdn.jsdelivr.net/npm/maplibre-gl@5.17.0/dist/maplibre-gl.css' rel='stylesheet' />

    <style>
      #map-{{ $mapname }} {
        width: {{ .Get "width" | default $mapparams.width }};
        height: {{ .Get "height" | default $mapparams.height }};
        border-radius: inherit;
      }
      
      /* Responsive design - stack on small screens */
      @media (max-width: 768px) {
        #map-{{ $mapname }} {
          height: 250px;
        }
      }
      
      /* Dark mode popup styling */
      @media (prefers-color-scheme: dark) {
        #map-{{ $mapname }} .maplibregl-popup-content {
          background-color: #2a2a2a;
          color: #e0e0e0;
          border: 1px solid #444;
        }
        #map-{{ $mapname }} .maplibregl-popup-tip {
          border-top-color: #2a2a2a;
        }
      }
      
      /* Light mode popup styling */
      @media (prefers-color-scheme: light) {
        #map-{{ $mapname }} .maplibregl-popup-content {
          background-color: #fff;
          color: #333;
          border: 1px solid #ddd;
        }
      }
    </style>

    <div id='map-{{ $mapname }}'></div>

    <script>
      // Setup global helpers if needed
      if (!window.hugoMapsHelpers) {
        window.hugoMapsHelpers = {
          validateLngLat: function(coords) {
            if (!coords) return null;
            if (typeof coords === 'string') {
              try {
                coords = JSON.parse(coords);
              } catch (e) {
                return null;
              }
            }
            if (Array.isArray(coords) && coords.length === 2) {
              const [first, second] = coords;
              if (typeof first === 'number' && typeof second === 'number' && 
                  first >= -180 && first <= 180 && second >= -90 && second <= 90) {
                return coords;
              }
            }
            if (typeof coords === 'object' && coords !== null) {
              let lng = coords.lng || coords.lon;
              let lat = coords.lat;
              if (typeof lng === 'number' && typeof lat === 'number' &&
                  lng >= -180 && lng <= 180 && lat >= -90 && lat <= 90) {
                return [lng, lat];
              }
            }
            return null;
          },

          geocoderApi: {
            // Default configuration - can be overridden per-provider
            defaults: {
              userAgent: 'hugo-maps/1.0',
              timeout: 10000
            },
            
            providers: {
              nominatim: {
                name: 'OpenStreetMap Nominatim',
                forwardGeocode: async function(query, config, defaults) {
                  const providerConfig = (config && config.nominatim) || {};
                  const baseUrl = providerConfig.url || 'https://nominatim.openstreetmap.org';
                  const userAgent = providerConfig.userAgent || defaults.userAgent;
                  const searchQuery = encodeURIComponent(query);
                  const request = `${baseUrl}/search?q=${searchQuery}&format=geojson&polygon_geojson=1&addressdetails=1`;
                  
                  console.log('Nominatim request:', request);
                  
                  const response = await fetch(request, {
                    headers: {
                      'User-Agent': userAgent,
                      'Accept': 'application/json'
                    }
                  });
                  
                  if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
                  
                  const geojson = await response.json();
                  if (!geojson.features || geojson.features.length === 0) {
                    console.warn('No features in Nominatim response');
                    return [];
                  }
                  
                  const features = [];
                  for (const feature of geojson.features) {
                    // Use centroid from geometry or calculate from bbox
                    let center;
                    if (feature.geometry && feature.geometry.type === 'Point') {
                      center = feature.geometry.coordinates;
                    } else if (feature.bbox && feature.bbox.length >= 4) {
                      center = [
                        feature.bbox[0] + (feature.bbox[2] - feature.bbox[0]) / 2,
                        feature.bbox[1] + (feature.bbox[3] - feature.bbox[1]) / 2
                      ];
                    } else if (feature.geometry && feature.geometry.coordinates) {
                      // Try to get first coordinate for polygons
                      const coords = feature.geometry.coordinates;
                      if (Array.isArray(coords) && coords.length > 0) {
                        if (Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                          center = coords[0][0]; // Polygon
                        } else if (Array.isArray(coords[0])) {
                          center = coords[0]; // LineString
                        } else {
                          center = coords; // Point
                        }
                      }
                    }
                    
                    if (!center) {
                      console.warn('Could not determine center for feature:', feature);
                      continue;
                    }
                    
                    features.push({
                      type: 'Feature',
                      geometry: { type: 'Point', coordinates: center },
                      place_name: feature.properties.display_name,
                      properties: feature.properties,
                      text: feature.properties.display_name,
                      place_type: ['place'],
                      center
                    });
                  }
                  
                  console.log('Nominatim returned ' + features.length + ' features');
                  return features;
                }
              },
              
              // Photon is a free alternative geocoder
              photon: {
                name: 'Photon (Komoot)',
                forwardGeocode: async function(query, config, defaults) {
                  const providerConfig = (config && config.photon) || {};
                  const baseUrl = providerConfig.url || 'https://photon.komoot.io';
                  const searchQuery = encodeURIComponent(query);
                  const request = `${baseUrl}/api/?q=${searchQuery}&limit=5`;
                  
                  console.log('Photon request:', request);
                  
                  const response = await fetch(request, {
                    headers: { 'Accept': 'application/json' }
                  });
                  
                  if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
                  
                  const geojson = await response.json();
                  if (!geojson.features || geojson.features.length === 0) {
                    console.warn('No features in Photon response');
                    return [];
                  }
                  
                  const features = geojson.features.map(feature => {
                    const props = feature.properties || {};
                    const placeParts = [props.name, props.city, props.state, props.country].filter(Boolean);
                    const placeName = placeParts.join(', ');
                    return {
                      type: 'Feature',
                      geometry: feature.geometry,
                      place_name: placeName,
                      properties: props,
                      text: props.name || placeName,
                      place_type: [props.osm_value || 'place'],
                      center: feature.geometry.coordinates
                    };
                  });
                  
                  console.log('Photon returned ' + features.length + ' features');
                  return features;
                }
              }
            },
            
            // Template-based geocoder for custom providers configured via YAML
            templateGeocode: async function(providerName, query, providerConfig, defaults) {
              const cfg = providerConfig || {};
              
              // Build URL with query parameters
              let url = cfg.url || '';
              const params = new URLSearchParams();
              
              // Process params - replace {query} and {apiKey} placeholders
              if (cfg.params) {
                for (const [key, value] of Object.entries(cfg.params)) {
                  let paramValue = String(value);
                  paramValue = paramValue.replace('{query}', query);
                  paramValue = paramValue.replace('{apiKey}', cfg.apiKey || '');
                  params.append(key, paramValue);
                }
              }
              
              // If URL contains {query} placeholder, replace it directly
              if (url.includes('{query}')) {
                url = url.replace('{query}', encodeURIComponent(query));
              }
              if (url.includes('{apiKey}')) {
                url = url.replace('{apiKey}', cfg.apiKey || '');
              }
              
              // Append params to URL
              const paramString = params.toString();
              if (paramString) {
                url += (url.includes('?') ? '&' : '?') + paramString;
              }
              
              console.log(`Template geocoder [${providerName}] request:`, url);
              
              // Build headers
              const headers = { 'Accept': 'application/json' };
              if (cfg.userAgent || defaults.userAgent) {
                headers['User-Agent'] = cfg.userAgent || defaults.userAgent;
              }
              if (cfg.headers) {
                Object.assign(headers, cfg.headers);
              }
              
              const response = await fetch(url, { headers });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              
              const data = await response.json();
              
              // Parse response based on format
              const format = cfg.format || 'auto';
              return this.parseGeocoderResponse(data, format, cfg);
            },
            
            // Parse geocoder responses in various formats
            parseGeocoderResponse: function(data, format, cfg) {
              const features = [];
              
              // Get the array of results from the response
              let results = data;
              if (cfg.resultsPath) {
                // Navigate to nested path like "results" or "data.items"
                for (const key of cfg.resultsPath.split('.')) {
                  results = results && results[key];
                }
              } else if (data.features) {
                results = data.features; // GeoJSON format
              } else if (Array.isArray(data)) {
                results = data; // Direct array
              }
              
              if (!results || !Array.isArray(results) || results.length === 0) {
                console.warn('No results found in geocoder response');
                return [];
              }
              
              for (const item of results) {
                let center = null;
                let placeName = '';
                
                // Extract coordinates based on format
                if (format === 'geojson' || (item.geometry && item.geometry.coordinates)) {
                  // GeoJSON format
                  center = item.geometry.coordinates;
                  placeName = (item.properties && item.properties.display_name) || 
                              (item.properties && item.properties.name) || '';
                } else if (item.lat !== undefined && item.lon !== undefined) {
                  // Nominatim-style (lat/lon as separate fields)
                  center = [parseFloat(item.lon), parseFloat(item.lat)];
                  placeName = item.display_name || item.name || '';
                } else if (item.lat !== undefined && item.lng !== undefined) {
                  // Google-style (lat/lng)
                  center = [parseFloat(item.lng), parseFloat(item.lat)];
                  placeName = item.formatted_address || item.display_name || item.name || '';
                } else if (item.geometry && item.geometry.lat !== undefined) {
                  // Google Places API style
                  center = [parseFloat(item.geometry.lng || item.geometry.lon), parseFloat(item.geometry.lat)];
                  placeName = item.formatted_address || item.name || '';
                } else if (item.center && Array.isArray(item.center)) {
                  // Already has center array
                  center = item.center;
                  placeName = item.place_name || item.text || '';
                } else if (item.bbox && item.bbox.length >= 4) {
                  // Calculate center from bounding box
                  center = [
                    (parseFloat(item.bbox[0]) + parseFloat(item.bbox[2])) / 2,
                    (parseFloat(item.bbox[1]) + parseFloat(item.bbox[3])) / 2
                  ];
                  placeName = item.display_name || item.name || '';
                } else if (cfg.latPath && cfg.lonPath) {
                  // Custom paths for lat/lon
                  const lat = this.getNestedValue(item, cfg.latPath);
                  const lon = this.getNestedValue(item, cfg.lonPath);
                  if (lat !== undefined && lon !== undefined) {
                    center = [parseFloat(lon), parseFloat(lat)];
                  }
                  placeName = cfg.namePath ? this.getNestedValue(item, cfg.namePath) : '';
                }
                
                if (!center) {
                  console.warn('Could not extract coordinates from result:', item);
                  continue;
                }
                
                // Get place name from custom path if specified
                if (cfg.namePath && !placeName) {
                  placeName = this.getNestedValue(item, cfg.namePath) || '';
                }
                
                features.push({
                  type: 'Feature',
                  geometry: { type: 'Point', coordinates: center },
                  place_name: placeName,
                  properties: item.properties || item,
                  text: placeName,
                  place_type: ['place'],
                  center
                });
              }
              
              console.log(`Template geocoder parsed ${features.length} features`);
              return features;
            },
            
            // Helper to get nested object values like "geometry.location.lat"
            getNestedValue: function(obj, path) {
              return path.split('.').reduce((current, key) => current && current[key], obj);
            },
            
            forwardGeocode: async function(config) {
              const providerList = config.providers 
                ? (Array.isArray(config.providers) ? config.providers : config.providers.split(',').map(s => s.trim()))
                : ['photon', 'nominatim'];
              const geocoderConfig = config.config || {};
              
              console.log('forwardGeocode called with providers:', providerList);
              
              for (const providerName of providerList) {
                try {
                  // Check for built-in provider first
                  const provider = this.providers[providerName];
                  if (provider) {
                    console.log(`Trying built-in provider: ${providerName}`);
                    const results = await provider.forwardGeocode(config.query, geocoderConfig, this.defaults);
                    
                    if (results && results.length > 0) {
                      console.log('Geocoding succeeded with ' + providerName);
                      return { features: results };
                    }
                  } else if (geocoderConfig[providerName] && geocoderConfig[providerName].url) {
                    // Use template geocoder for custom providers defined in config
                    console.log(`Trying template provider: ${providerName}`);
                    const results = await this.templateGeocode(
                      providerName, 
                      config.query, 
                      geocoderConfig[providerName], 
                      this.defaults
                    );
                    
                    if (results && results.length > 0) {
                      console.log('Geocoding succeeded with template provider: ' + providerName);
                      return { features: results };
                    }
                  } else {
                    console.warn(`Geocoder provider '${providerName}' not found and no config provided`);
                  }
                } catch (e) {
                  console.error(`Geocoder '${providerName}' failed:`, e.message);
                  continue;
                }
              }
              
              console.error('All geocoders failed or returned no results');
              return { features: [] };
            }
          }
        };
      }

      // Immediately initialize this map (IIFE)
      (function() {
        function tryInit() {
          if (typeof maplibregl === 'undefined') {
            setTimeout(tryInit, 50);
            return;
          }

          const mapId = 'map-{{ $mapname }}';
          const container = document.getElementById(mapId);
          if (!container) {
            console.error('Map container not found:', mapId);
            return;
          }

          const center = window.hugoMapsHelpers.validateLngLat({{ $mapparams.center | jsonify }}) || [-0.127758, 51.507351];
          
          const map = new maplibregl.Map({
            container: mapId,
            center: center,
            minZoom: {{ $mapparams.minZoom | default 0 }},
            maxZoom: {{ $mapparams.maxZoom | default 23 }},
            zoom: {{ $mapparams.zoom | default 11 }},
            bearing: {{ $mapparams.bearing | default 0 }},
            minPitch: {{ $mapparams.minPitch | default 0 }},
            maxPitch: {{ $mapparams.maxPitch | default 60 }},
            pitch: {{ $mapparams.pitch | default 0 }},
            antialias: {{ $mapparams.antialias | default false }},
            attributionControl: {{ $mapparams.attributionControl | default true }},
            customAttribution: "{{ $mapparams.customAttribution | default "" }}",
            interactive: {{ $mapparams.interactive | default true }},
            style: {{ $mapstyle | jsonify | safeJS }}
          });

          {{- if $mapparams.navigationControl }}
          map.addControl(new maplibregl.NavigationControl());
          {{- end }}

          {{- if $mapAddress }}
          {{- $geocodersValue := $mapparams.geocoders | default "nominatim" -}}
          const handleGeocode = function() {
            {{- if reflect.IsSlice $geocodersValue }}
            const providers = {{ $geocodersValue | jsonify }};
            {{- else }}
            const providers = "{{ $geocodersValue }}";
            {{- end }}
            window.hugoMapsHelpers.geocoderApi.forwardGeocode({
              query: '{{ $mapAddress }}',
              providers: providers,
              config: {{ $mapparams.geocoderConfig | default dict | jsonify | safeJS }}
            })
              .then((result) => {
                if (result.features && result.features.length > 0) {
                  const feature = result.features[0];
                  {{- if $addressZoom }}
                  const addressZoom = {{ $addressZoom }};
                  {{- else }}
                  const addressZoom = {{ $mapparams.zoom | default 11 }};
                  {{- end }}
                  map.flyTo({
                    center: feature.center,
                    zoom: addressZoom,
                    duration: {{ $mapparams.flyToDuration | default 2500 }},
                    bearing: {{ $mapparams.bearing | default 0 }},
                    pitch: {{ $mapparams.pitch | default 0 }}
                  });
                  // Create a marker at the geocoded location with popup
                  const addressMarker = new maplibregl.Marker()
                    .setLngLat(feature.center);
                  
                  {{- if eq ($mapparams.popupTrigger | default "hover") "click" }}
                  // Click-triggered popup
                  addressMarker
                    .setPopup(
                      new maplibregl.Popup()
                        .setHTML("<strong>{{ .Page.Title }}</strong>")
                    )
                    .addTo(map)
                    .togglePopup();
                  {{- else }}
                  // Hover-triggered popup
                  addressMarker.addTo(map);
                  
                  const addressPopup = new maplibregl.Popup({
                    closeButton: false,
                    closeOnClick: false
                  });
                  
                  const addressMarkerEl = addressMarker.getElement();
                  addressMarkerEl.style.cursor = 'pointer';
                  
                  addressMarkerEl.addEventListener('mouseenter', () => {
                    addressPopup
                      .setLngLat(feature.center)
                      .setHTML("<strong>{{ .Page.Title }}</strong>")
                      .addTo(map);
                  });
                  
                  addressMarkerEl.addEventListener('mouseleave', () => {
                    addressPopup.remove();
                  });
                  {{- end }}
                }
              })
              .catch((err) => {
                console.error('Geocode error:', err);
              });
          };
          
          if (map.isStyleLoaded()) {
            handleGeocode();
          } else {
            map.on('load', handleGeocode);
          }
          {{- end }}

          {{- range $index, $marker := $mapparams.markers }}
          (function() {
            const markerCoords_{{ $index }} = window.hugoMapsHelpers.validateLngLat({{ .location | jsonify }});
            const marker_{{ $index }} = new maplibregl.Marker()
              .setLngLat(markerCoords_{{ $index }});
            
            {{- if eq ($mapparams.popupTrigger | default "hover") "click" }}
            // Click-triggered popup
            marker_{{ $index }}
              .setPopup(new maplibregl.Popup().setHTML("{{ .text }}"))
              .addTo(map);
            {{- else }}
            // Hover-triggered popup
            marker_{{ $index }}.addTo(map);
            
            const popup_{{ $index }} = new maplibregl.Popup({
              closeButton: false,
              closeOnClick: false
            });
            
            const markerEl_{{ $index }} = marker_{{ $index }}.getElement();
            markerEl_{{ $index }}.style.cursor = 'pointer';
            
            markerEl_{{ $index }}.addEventListener('mouseenter', () => {
              popup_{{ $index }}
                .setLngLat(markerCoords_{{ $index }})
                .setHTML("{{ .text }}")
                .addTo(map);
            });
            
            markerEl_{{ $index }}.addEventListener('mouseleave', () => {
              popup_{{ $index }}.remove();
            });
            {{- end }}
          })();
          {{- end }}

          {{- range $mapparams.setfeaturestate }}
          map.on('data', function(e) {
            map.setFeatureState({{ .feature | jsonify }}, {{ .state | jsonify }});
          });
          {{- end }}
        }

        // Trigger on DOM ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', tryInit);
        } else {
          tryInit();
        }
      })();
    </script>
  {{- end -}}
{{- end -}}