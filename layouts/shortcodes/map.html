{{- if not (.Get "name") -}}
<p>Error: No map name specified. Please specify a map name in the shortcode. Example: \{\{&lt; map name="mapname" &gt;\}\}</p>
{{- else -}}
  {{- $mapConfigName := .Get "name" -}}
  {{- $hugoMapsConfig := index site.Params "hugo-maps" -}}
  {{- $mapparams := index $hugoMapsConfig $mapConfigName -}}

  {{- if not $mapparams -}}
<p>Error: Map name {{- $mapConfigName -}} not found in config. Please check your config file.</p>
  {{- else -}}
    {{- $mapname := md5 now.UnixNano -}}
    {{- $baseparams := (resources.Get "default/mapparams.yaml") | unmarshal -}}
    {{- $defaultparams := index $hugoMapsConfig "default" | default dict -}}
    {{- $mapparams = merge $baseparams $defaultparams $mapparams -}}
    {{- $addressZoom := .Get "address-zoom" | default .Page.Params.addressZoom | default ($mapparams.addressZoom | default "") -}}
    {{- $geocodeAtBuild := $mapparams.geocodeAtBuild | default true -}}
    
    {{- /* Content Map mode - aggregate pages with addresses */ -}}
    {{- $contentMapConfig := $mapparams.contentMap | default dict -}}
    {{- $contentMapEnabled := $contentMapConfig.enabled | default false -}}
    {{- $locations := slice -}}
    {{- if $contentMapEnabled -}}
      {{- $pages := site.RegularPages -}}
      {{- $section := $contentMapConfig.section | default "" -}}
      {{- if $section -}}
        {{- $pages = where $pages "Section" $section -}}
      {{- end -}}
      {{- /* Apply frontmatter filters */ -}}
      {{- $filter := $contentMapConfig.filter | default dict -}}
      {{- range $key, $value := $filter -}}
        {{- $pages = where $pages (printf ".Params.%s" $key) $value -}}
      {{- end -}}
      {{- /* Apply taxonomy term filters */ -}}
      {{- $terms := $contentMapConfig.terms | default dict -}}
      {{- range $taxonomy, $termValue := $terms -}}
        {{- if reflect.IsSlice $termValue -}}
          {{- /* Multiple terms - page must have at least one */ -}}
          {{- $termPages := slice -}}
          {{- range $term := $termValue -}}
            {{- $termPages = $termPages | append (where $pages (printf ".Params.%s" $taxonomy) "intersect" (slice $term)) -}}
          {{- end -}}
          {{- $pages = $termPages | uniq -}}
        {{- else -}}
          {{- /* Single term */ -}}
          {{- $pages = where $pages (printf ".Params.%s" $taxonomy) "intersect" (slice $termValue) -}}
        {{- end -}}
      {{- end -}}
      {{- $geocodeParams := $mapparams.geocodeParams | default "address" -}}
      {{- range $pages -}}
        {{- $addr := "" -}}
        {{- if reflect.IsSlice $geocodeParams -}}
          {{- $parts := slice -}}
          {{- range $geocodeParams -}}
            {{- $val := index $.Params . -}}
            {{- if $val -}}
              {{- $parts = $parts | append (printf "%v" $val) -}}
            {{- end -}}
          {{- end -}}
          {{- $addr = delimit $parts ", " -}}
        {{- else -}}
          {{- $addr = index .Params (printf "%v" $geocodeParams) -}}
        {{- end -}}
        {{- if $addr -}}
          {{- $loc := dict 
              "title" .Title 
              "link" .Permalink
              "address" $addr
              "description" (.Params.description | default "")
          -}}
          {{- /* Pre-geocode at build time if enabled */ -}}
          {{- if $geocodeAtBuild -}}
            {{- $geocodeResult := partial "hugo-maps/geocode.html" (dict "address" $addr "config" $mapparams) -}}
            {{- if $geocodeResult.success -}}
              {{- $loc = merge $loc (dict "coordinates" (slice $geocodeResult.lng $geocodeResult.lat) "geocoded" true) -}}
            {{- end -}}
          {{- end -}}
          {{- $locations = $locations | append $loc -}}
        {{- end -}}
      {{- end -}}
    {{- end -}}
    
    {{- /* Build geocode query from configured parameters (for single-marker mode) */ -}}
    {{- $geocodeParams := $mapparams.geocodeParams | default "address" -}}
    {{- $mapAddress := "" -}}
    {{- if reflect.IsMap $geocodeParams -}}
      {{- /* If it's a map/dict, use it as-is (shouldn't happen but just in case) */ -}}
      {{- $mapAddress = index $.Page.Params "address" -}}
    {{- else if reflect.IsSlice $geocodeParams -}}
      {{- /* It's an array of parameter names - combine them */ -}}
      {{- $parts := slice -}}
      {{- range $geocodeParams -}}
        {{- $val := index $.Page.Params . -}}
        {{- if $val -}}
          {{- $parts = $parts | append (printf "%v" $val) -}}
        {{- end -}}
      {{- end -}}
      {{- $mapAddress = delimit $parts ", " -}}
    {{- else -}}
      {{- /* It's a string parameter name */ -}}
      {{- $mapAddress = index $.Page.Params (printf "%v" $geocodeParams) -}}
    {{- end -}}
    {{- /* Allow shortcode override */ -}}
    {{- $mapAddress = .Get "address" | default $mapAddress -}}
    {{- $addressZoom := .Get "address-zoom" | default $.Page.Params.addressZoom | default ($mapparams.addressZoom | default "") -}}
    
    {{- /* Pre-geocode single address at build time if enabled */ -}}
    {{- $preGeocodedCoords := slice -}}
    {{- $preGeocodedPlaceName := "" -}}
    {{- if and $mapAddress $geocodeAtBuild -}}
      {{- $geocodeResult := partial "hugo-maps/geocode.html" (dict "address" $mapAddress "config" $mapparams) -}}
      {{- if $geocodeResult.success -}}
        {{- $preGeocodedCoords = slice $geocodeResult.lng $geocodeResult.lat -}}
        {{- $preGeocodedPlaceName = $geocodeResult.placeName -}}
      {{- end -}}
    {{- end -}}

    {{- $mapstyle := dict -}}

    {{- if eq ($mapparams.type | default "remote") "remote" -}}
      {{- $sources := dict "sources" ($mapparams.sources | default dict) -}}
      {{- $mapstyle = resources.Get (printf "map-styles/%s.json" ($mapparams.style | default "osm-bright")) | unmarshal -}}
      {{- $mapstyle = merge $mapstyle $sources -}}
    {{- end -}}

    <script src='https://cdn.jsdelivr.net/npm/maplibre-gl@5.17.0/dist/maplibre-gl.js'></script>
    <link href='https://cdn.jsdelivr.net/npm/maplibre-gl@5.17.0/dist/maplibre-gl.css' rel='stylesheet' />

    <style>
      #map-{{ $mapname }} {
        width: {{ .Get "width" | default $mapparams.width }};
        height: {{ .Get "height" | default $mapparams.height }};
        border-radius: inherit;
      }
      
      /* Responsive design - stack on small screens */
      @media (max-width: 768px) {
        #map-{{ $mapname }} {
          height: 250px;
        }
      }
      
      /* Dark mode popup styling */
      @media (prefers-color-scheme: dark) {
        #map-{{ $mapname }} .maplibregl-popup-content {
          background-color: #2a2a2a;
          color: #e0e0e0;
          border: 1px solid #444;
        }
        #map-{{ $mapname }} .maplibregl-popup-tip {
          border-top-color: #2a2a2a;
        }
      }
      
      /* Light mode popup styling */
      @media (prefers-color-scheme: light) {
        #map-{{ $mapname }} .maplibregl-popup-content {
          background-color: #fff;
          color: #333;
          border: 1px solid #ddd;
        }
      }
      
      /* Popup link styling */
      #map-{{ $mapname }} .maplibregl-popup-content a {
        color: inherit;
        text-decoration: underline;
      }
    </style>

    <div id='map-{{ $mapname }}'></div>

    <script>
      // Setup global helpers if needed
      if (!window.hugoMapsHelpers) {
        window.hugoMapsHelpers = {
          validateLngLat: function(coords) {
            if (!coords) return null;
            if (typeof coords === 'string') {
              // Remove any extra whitespace
              coords = coords.trim();
              // Try to parse as JSON
              try {
                coords = JSON.parse(coords);
              } catch (e) {
                // Try comma-separated format: "-93.1023,44.9532"
                var parts = coords.split(',');
                if (parts.length === 2) {
                  var lng = parseFloat(parts[0].trim());
                  var lat = parseFloat(parts[1].trim());
                  if (!isNaN(lng) && !isNaN(lat)) {
                    coords = [lng, lat];
                  } else {
                    return null;
                  }
                } else {
                  return null;
                }
              }
            }
            if (Array.isArray(coords) && coords.length === 2) {
              var first = parseFloat(coords[0]);
              var second = parseFloat(coords[1]);
              if (!isNaN(first) && !isNaN(second) &&
                  first >= -180 && first <= 180 && second >= -90 && second <= 90) {
                return [first, second];
              }
            }
            if (typeof coords === 'object' && coords !== null) {
              var lng = parseFloat(coords.lng || coords.lon);
              var lat = parseFloat(coords.lat);
              if (!isNaN(lng) && !isNaN(lat) &&
                  lng >= -180 && lng <= 180 && lat >= -90 && lat <= 90) {
                return [lng, lat];
              }
            }
            return null;
          },

          geocoderApi: {
            // Default configuration - can be overridden per-provider
            defaults: {
              userAgent: 'hugo-maps/1.0',
              timeout: 10000
            },
            
            providers: {
              nominatim: {
                name: 'OpenStreetMap Nominatim',
                forwardGeocode: async function(query, config, defaults) {
                  const providerConfig = (config && config.nominatim) || {};
                  const baseUrl = providerConfig.url || 'https://nominatim.openstreetmap.org';
                  const userAgent = providerConfig.userAgent || defaults.userAgent;
                  const searchQuery = encodeURIComponent(query);
                  const request = `${baseUrl}/search?q=${searchQuery}&format=geojson&polygon_geojson=1&addressdetails=1`;
                  
                  console.log('Nominatim request:', request);
                  
                  const response = await fetch(request, {
                    headers: {
                      'User-Agent': userAgent,
                      'Accept': 'application/json'
                    }
                  });
                  
                  if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
                  
                  const geojson = await response.json();
                  if (!geojson.features || geojson.features.length === 0) {
                    console.warn('No features in Nominatim response');
                    return [];
                  }
                  
                  const features = [];
                  for (const feature of geojson.features) {
                    // Use centroid from geometry or calculate from bbox
                    let center;
                    if (feature.geometry && feature.geometry.type === 'Point') {
                      center = feature.geometry.coordinates;
                    } else if (feature.bbox && feature.bbox.length >= 4) {
                      center = [
                        feature.bbox[0] + (feature.bbox[2] - feature.bbox[0]) / 2,
                        feature.bbox[1] + (feature.bbox[3] - feature.bbox[1]) / 2
                      ];
                    } else if (feature.geometry && feature.geometry.coordinates) {
                      // Try to get first coordinate for polygons
                      const coords = feature.geometry.coordinates;
                      if (Array.isArray(coords) && coords.length > 0) {
                        if (Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                          center = coords[0][0]; // Polygon
                        } else if (Array.isArray(coords[0])) {
                          center = coords[0]; // LineString
                        } else {
                          center = coords; // Point
                        }
                      }
                    }
                    
                    if (!center) {
                      console.warn('Could not determine center for feature:', feature);
                      continue;
                    }
                    
                    features.push({
                      type: 'Feature',
                      geometry: { type: 'Point', coordinates: center },
                      place_name: feature.properties.display_name,
                      properties: feature.properties,
                      text: feature.properties.display_name,
                      place_type: ['place'],
                      center
                    });
                  }
                  
                  console.log('Nominatim returned ' + features.length + ' features');
                  return features;
                }
              },
              
              // Photon is a free alternative geocoder
              photon: {
                name: 'Photon (Komoot)',
                forwardGeocode: async function(query, config, defaults) {
                  const providerConfig = (config && config.photon) || {};
                  const baseUrl = providerConfig.url || 'https://photon.komoot.io';
                  const searchQuery = encodeURIComponent(query);
                  const request = `${baseUrl}/api/?q=${searchQuery}&limit=5`;
                  
                  console.log('Photon request:', request);
                  
                  const response = await fetch(request, {
                    headers: { 'Accept': 'application/json' }
                  });
                  
                  if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
                  
                  const geojson = await response.json();
                  if (!geojson.features || geojson.features.length === 0) {
                    console.warn('No features in Photon response');
                    return [];
                  }
                  
                  const features = geojson.features.map(feature => {
                    const props = feature.properties || {};
                    const placeParts = [props.name, props.city, props.state, props.country].filter(Boolean);
                    const placeName = placeParts.join(', ');
                    return {
                      type: 'Feature',
                      geometry: feature.geometry,
                      place_name: placeName,
                      properties: props,
                      text: props.name || placeName,
                      place_type: [props.osm_value || 'place'],
                      center: feature.geometry.coordinates
                    };
                  });
                  
                  console.log('Photon returned ' + features.length + ' features');
                  return features;
                }
              }
            },
            
            // Template-based geocoder for custom providers configured via YAML
            templateGeocode: async function(providerName, query, providerConfig, defaults) {
              const cfg = providerConfig || {};
              
              // Build URL with query parameters
              let url = cfg.url || '';
              const params = new URLSearchParams();
              
              // Process params - replace {query} and {apiKey} placeholders
              if (cfg.params) {
                for (const [key, value] of Object.entries(cfg.params)) {
                  let paramValue = String(value);
                  paramValue = paramValue.replace('{query}', query);
                  paramValue = paramValue.replace('{apiKey}', cfg.apiKey || '');
                  params.append(key, paramValue);
                }
              }
              
              // If URL contains {query} placeholder, replace it directly
              if (url.includes('{query}')) {
                url = url.replace('{query}', encodeURIComponent(query));
              }
              if (url.includes('{apiKey}')) {
                url = url.replace('{apiKey}', cfg.apiKey || '');
              }
              
              // Append params to URL
              const paramString = params.toString();
              if (paramString) {
                url += (url.includes('?') ? '&' : '?') + paramString;
              }
              
              console.log(`Template geocoder [${providerName}] request:`, url);
              
              // Build headers
              const headers = { 'Accept': 'application/json' };
              if (cfg.userAgent || defaults.userAgent) {
                headers['User-Agent'] = cfg.userAgent || defaults.userAgent;
              }
              if (cfg.headers) {
                Object.assign(headers, cfg.headers);
              }
              
              const response = await fetch(url, { headers });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              
              const data = await response.json();
              
              // Parse response based on format
              const format = cfg.format || 'auto';
              return this.parseGeocoderResponse(data, format, cfg);
            },
            
            // Parse geocoder responses in various formats
            parseGeocoderResponse: function(data, format, cfg) {
              const features = [];
              
              // Get the array of results from the response
              let results = data;
              if (cfg.resultsPath) {
                // Navigate to nested path like "results" or "data.items"
                for (const key of cfg.resultsPath.split('.')) {
                  results = results && results[key];
                }
              } else if (data.features) {
                results = data.features; // GeoJSON format
              } else if (Array.isArray(data)) {
                results = data; // Direct array
              }
              
              if (!results || !Array.isArray(results) || results.length === 0) {
                console.warn('No results found in geocoder response');
                return [];
              }
              
              for (const item of results) {
                let center = null;
                let placeName = '';
                
                // Extract coordinates based on format
                if (format === 'geojson' || (item.geometry && item.geometry.coordinates)) {
                  // GeoJSON format
                  center = item.geometry.coordinates;
                  placeName = (item.properties && item.properties.display_name) || 
                              (item.properties && item.properties.name) || '';
                } else if (item.lat !== undefined && item.lon !== undefined) {
                  // Nominatim-style (lat/lon as separate fields)
                  center = [parseFloat(item.lon), parseFloat(item.lat)];
                  placeName = item.display_name || item.name || '';
                } else if (item.lat !== undefined && item.lng !== undefined) {
                  // Google-style (lat/lng)
                  center = [parseFloat(item.lng), parseFloat(item.lat)];
                  placeName = item.formatted_address || item.display_name || item.name || '';
                } else if (item.geometry && item.geometry.lat !== undefined) {
                  // Google Places API style
                  center = [parseFloat(item.geometry.lng || item.geometry.lon), parseFloat(item.geometry.lat)];
                  placeName = item.formatted_address || item.name || '';
                } else if (item.center && Array.isArray(item.center)) {
                  // Already has center array
                  center = item.center;
                  placeName = item.place_name || item.text || '';
                } else if (item.bbox && item.bbox.length >= 4) {
                  // Calculate center from bounding box
                  center = [
                    (parseFloat(item.bbox[0]) + parseFloat(item.bbox[2])) / 2,
                    (parseFloat(item.bbox[1]) + parseFloat(item.bbox[3])) / 2
                  ];
                  placeName = item.display_name || item.name || '';
                } else if (cfg.latPath && cfg.lonPath) {
                  // Custom paths for lat/lon
                  const lat = this.getNestedValue(item, cfg.latPath);
                  const lon = this.getNestedValue(item, cfg.lonPath);
                  if (lat !== undefined && lon !== undefined) {
                    center = [parseFloat(lon), parseFloat(lat)];
                  }
                  placeName = cfg.namePath ? this.getNestedValue(item, cfg.namePath) : '';
                }
                
                if (!center) {
                  console.warn('Could not extract coordinates from result:', item);
                  continue;
                }
                
                // Get place name from custom path if specified
                if (cfg.namePath && !placeName) {
                  placeName = this.getNestedValue(item, cfg.namePath) || '';
                }
                
                features.push({
                  type: 'Feature',
                  geometry: { type: 'Point', coordinates: center },
                  place_name: placeName,
                  properties: item.properties || item,
                  text: placeName,
                  place_type: ['place'],
                  center
                });
              }
              
              console.log(`Template geocoder parsed ${features.length} features`);
              return features;
            },
            
            // Helper to get nested object values like "geometry.location.lat"
            getNestedValue: function(obj, path) {
              return path.split('.').reduce((current, key) => current && current[key], obj);
            },
            
            forwardGeocode: async function(config) {
              const providerList = config.providers 
                ? (Array.isArray(config.providers) ? config.providers : config.providers.split(',').map(s => s.trim()))
                : ['photon', 'nominatim'];
              const geocoderConfig = config.config || {};
              
              console.log('forwardGeocode called with providers:', providerList);
              
              for (const providerName of providerList) {
                try {
                  // Check for built-in provider first
                  const provider = this.providers[providerName];
                  if (provider) {
                    console.log(`Trying built-in provider: ${providerName}`);
                    const results = await provider.forwardGeocode(config.query, geocoderConfig, this.defaults);
                    
                    if (results && results.length > 0) {
                      console.log('Geocoding succeeded with ' + providerName);
                      return { features: results };
                    }
                  } else if (geocoderConfig[providerName] && geocoderConfig[providerName].url) {
                    // Use template geocoder for custom providers defined in config
                    console.log(`Trying template provider: ${providerName}`);
                    const results = await this.templateGeocode(
                      providerName, 
                      config.query, 
                      geocoderConfig[providerName], 
                      this.defaults
                    );
                    
                    if (results && results.length > 0) {
                      console.log('Geocoding succeeded with template provider: ' + providerName);
                      return { features: results };
                    }
                  } else {
                    console.warn(`Geocoder provider '${providerName}' not found and no config provided`);
                  }
                } catch (e) {
                  console.error(`Geocoder '${providerName}' failed:`, e.message);
                  continue;
                }
              }
              
              console.error('All geocoders failed or returned no results');
              return { features: [] };
            }
          }
        };
      }

      // Immediately initialize this map (IIFE)
      (function() {
        function tryInit() {
          if (typeof maplibregl === 'undefined') {
            setTimeout(tryInit, 50);
            return;
          }

          const mapId = 'map-{{ $mapname }}';
          const container = document.getElementById(mapId);
          if (!container) {
            console.error('Map container not found:', mapId);
            return;
          }

          var center = [{{ index $mapparams.center 0 | default -0.127758 }}, {{ index $mapparams.center 1 | default 51.507351 }}];
          
          const map = new maplibregl.Map({
            container: mapId,
            center: center,
            minZoom: {{ $mapparams.minZoom | default 0 }},
            maxZoom: {{ $mapparams.maxZoom | default 23 }},
            zoom: {{ $mapparams.zoom | default 11 }},
            bearing: {{ $mapparams.bearing | default 0 }},
            minPitch: {{ $mapparams.minPitch | default 0 }},
            maxPitch: {{ $mapparams.maxPitch | default 60 }},
            pitch: {{ $mapparams.pitch | default 0 }},
            antialias: {{ $mapparams.antialias | default false }},
            attributionControl: {{ $mapparams.attributionControl | default true }},
            customAttribution: "{{ $mapparams.customAttribution | default "" }}",
            interactive: {{ $mapparams.interactive | default true }},
            style: {{ $mapstyle | jsonify | safeJS }}
          });

          {{- if $mapparams.navigationControl }}
          map.addControl(new maplibregl.NavigationControl());
          {{- end }}

          {{- if $contentMapEnabled }}
          {{- /* Content Map mode - geocode and display multiple locations */ -}}
          {{- $geocodersValue := $mapparams.geocoders | default "photon,nominatim" -}}
          var locations = {{ $locations | jsonify | safeJS }};
          var geocoderConfig = {{ $mapparams.geocoderConfig | default dict | jsonify | safeJS }};
          {{- if reflect.IsSlice $geocodersValue }}
          var providers = {{ $geocodersValue | jsonify }};
          {{- else }}
          var providers = "{{ $geocodersValue }}";
          {{- end }}
          var popupTrigger = "{{ $mapparams.popupTrigger | default "hover" }}";
          var markerColor = "{{ $mapparams.markerColor | default "#114477" }}";
          
          async function addContentMarkers() {
            var bounds = new maplibregl.LngLatBounds();
            var markersAdded = 0;
            
            for (var i = 0; i < locations.length; i++) {
              var loc = locations[i];
              try {
                var coords = null;
                
                // Use pre-geocoded coordinates if available (build-time geocoding)
                if (loc.geocoded && loc.coordinates && Array.isArray(loc.coordinates)) {
                  coords = loc.coordinates;
                  console.log('Using pre-geocoded coordinates for:', loc.title);
                } else {
                  // Fall back to client-side geocoding
                  var result = await window.hugoMapsHelpers.geocoderApi.forwardGeocode({
                    query: loc.address,
                    providers: providers,
                    config: geocoderConfig
                  });
                  
                  if (result.features && result.features.length > 0) {
                    coords = result.features[0].center;
                  }
                }
                
                if (coords && Array.isArray(coords) && coords.length === 2) {
                    var popupContent = loc.description 
                      ? '<strong><a href="' + loc.link + '">' + loc.title + '</a></strong><br>' + loc.description
                      : '<strong><a href="' + loc.link + '">' + loc.title + '</a></strong>';
                    
                    var marker = new maplibregl.Marker({ color: markerColor })
                      .setLngLat(coords);
                    
                    if (popupTrigger === 'click') {
                      marker.setPopup(new maplibregl.Popup().setHTML(popupContent)).addTo(map);
                    } else {
                      marker.addTo(map);
                      (function(m, c, html) {
                        var popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false, offset: 25 });
                        var el = m.getElement();
                        el.style.cursor = 'pointer';
                        el.addEventListener('mouseenter', function() {
                          popup.setLngLat(c).setHTML(html).addTo(map);
                        });
                        el.addEventListener('mouseleave', function() {
                          popup.remove();
                        });
                      })(marker, coords, popupContent);
                    }
                    
                    bounds.extend(coords);
                    markersAdded++;
                }
              } catch (err) {
                console.error('Geocode error for ' + loc.address + ':', err);
              }
            }
            
            if (markersAdded > 1) {
              map.fitBounds(bounds, { padding: 50, maxZoom: 15 });
            } else if (markersAdded === 1) {
              map.setCenter(bounds.getCenter());
              map.setZoom({{ $mapparams.zoom | default 13 }});
            }
          }
          
          if (map.isStyleLoaded()) {
            addContentMarkers();
          } else {
            map.on('load', addContentMarkers);
          }
          {{- else }}
          {{- /* Single marker mode */ -}}
          {{- if $mapAddress }}
          {{- $geocodersValue := $mapparams.geocoders | default "nominatim" -}}
          
          {{- /* Check if we have pre-geocoded coordinates from build time */ -}}
          {{- if $preGeocodedCoords }}
          // Using pre-geocoded coordinates (build-time geocoding)
          (function() {
            var preGeocodedCenter = {{ $preGeocodedCoords | jsonify | safeJS }};
            {{- if $addressZoom }}
            var addressZoom = {{ $addressZoom }};
            {{- else }}
            var addressZoom = {{ $mapparams.zoom | default 11 }};
            {{- end }}
            
            function showPreGeocodedMarker() {
              map.flyTo({
                center: preGeocodedCenter,
                zoom: addressZoom,
                duration: {{ $mapparams.flyToDuration | default 2500 }},
                bearing: {{ $mapparams.bearing | default 0 }},
                pitch: {{ $mapparams.pitch | default 0 }}
              });
              
              var addressMarker = new maplibregl.Marker({ color: '{{ $mapparams.markerColor | default "#114477" }}' })
                .setLngLat(preGeocodedCenter);
              
              {{- if eq ($mapparams.popupTrigger | default "hover") "click" }}
              addressMarker
                .setPopup(
                  new maplibregl.Popup()
                    .setHTML("<strong>{{ .Page.Title }}</strong>")
                )
                .addTo(map)
                .togglePopup();
              {{- else }}
              addressMarker.addTo(map);
              
              var addressPopup = new maplibregl.Popup({
                closeButton: false,
                closeOnClick: false,
                offset: 25
              });
              
              var addressMarkerEl = addressMarker.getElement();
              addressMarkerEl.style.cursor = 'pointer';
              
              addressMarkerEl.addEventListener('mouseenter', function() {
                addressPopup
                  .setLngLat(preGeocodedCenter)
                  .setHTML("<strong>{{ .Page.Title }}</strong>")
                  .addTo(map);
              });
              
              addressMarkerEl.addEventListener('mouseleave', function() {
                addressPopup.remove();
              });
              {{- end }}
            }
            
            if (map.isStyleLoaded()) {
              showPreGeocodedMarker();
            } else {
              map.on('load', showPreGeocodedMarker);
            }
          })();
          {{- else }}
          // Fall back to client-side geocoding
          const handleGeocode = function() {
            {{- if reflect.IsSlice $geocodersValue }}
            const providers = {{ $geocodersValue | jsonify }};
            {{- else }}
            const providers = "{{ $geocodersValue }}";
            {{- end }}
            window.hugoMapsHelpers.geocoderApi.forwardGeocode({
              query: '{{ $mapAddress }}',
              providers: providers,
              config: {{ $mapparams.geocoderConfig | default dict | jsonify | safeJS }}
            })
              .then((result) => {
                if (result.features && result.features.length > 0) {
                  const feature = result.features[0];
                  {{- if $addressZoom }}
                  const addressZoom = {{ $addressZoom }};
                  {{- else }}
                  const addressZoom = {{ $mapparams.zoom | default 11 }};
                  {{- end }}
                  map.flyTo({
                    center: feature.center,
                    zoom: addressZoom,
                    duration: {{ $mapparams.flyToDuration | default 2500 }},
                    bearing: {{ $mapparams.bearing | default 0 }},
                    pitch: {{ $mapparams.pitch | default 0 }}
                  });
                  // Create a marker at the geocoded location with popup
                  var addressMarker = new maplibregl.Marker({ color: '{{ $mapparams.markerColor | default "#114477" }}' })
                    .setLngLat(feature.center);
                  
                  {{- if eq ($mapparams.popupTrigger | default "hover") "click" }}
                  // Click-triggered popup
                  addressMarker
                    .setPopup(
                      new maplibregl.Popup()
                        .setHTML("<strong>{{ .Page.Title }}</strong>")
                    )
                    .addTo(map)
                    .togglePopup();
                  {{- else }}
                  // Hover-triggered popup
                  addressMarker.addTo(map);
                  
                  var addressPopup = new maplibregl.Popup({
                    closeButton: false,
                    closeOnClick: false,
                    offset: 25
                  });
                  
                  var addressMarkerEl = addressMarker.getElement();
                  addressMarkerEl.style.cursor = 'pointer';
                  
                  addressMarkerEl.addEventListener('mouseenter', function() {
                    addressPopup
                      .setLngLat(feature.center)
                      .setHTML("<strong>{{ .Page.Title }}</strong>")
                      .addTo(map);
                  });
                  
                  addressMarkerEl.addEventListener('mouseleave', function() {
                    addressPopup.remove();
                  });
                  {{- end }}
                }
              })
              .catch((err) => {
                console.error('Geocode error:', err);
              });
          };
          
          if (map.isStyleLoaded()) {
            handleGeocode();
          } else {
            map.on('load', handleGeocode);
          }
          {{- end }}{{- /* end if preGeocodedCoords */ -}}
          {{- end }}

          {{- range $mapparams.markers }}
          (function() {
            var coords = window.hugoMapsHelpers.validateLngLat({{ .location | jsonify }});
            var marker = new maplibregl.Marker({ color: '{{ $mapparams.markerColor | default "#114477" }}' }).setLngLat(coords);
            
            {{- if eq ($mapparams.popupTrigger | default "hover") "click" }}
            marker.setPopup(new maplibregl.Popup().setHTML("{{ .text }}")).addTo(map);
            {{- else }}
            marker.addTo(map);
            var popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false, offset: 25 });
            var el = marker.getElement();
            el.style.cursor = 'pointer';
            el.addEventListener('mouseenter', function() {
              popup.setLngLat(coords).setHTML("{{ .text }}").addTo(map);
            });
            el.addEventListener('mouseleave', function() {
              popup.remove();
            });
            {{- end }}
          })();
          {{- end }}

          {{- range $mapparams.setfeaturestate }}
          map.on('data', function(e) {
            map.setFeatureState({{ .feature | jsonify }}, {{ .state | jsonify }});
          });
          {{- end }}
          {{- end }}{{- /* end if not contentMap */ -}}
        }

        // Trigger on DOM ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', tryInit);
        } else {
          tryInit();
        }
      })();
    </script>
  {{- end -}}
{{- end -}}