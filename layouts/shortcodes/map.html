{{- if not (.Get "name") -}}
<p>Error: No map name specified. Please specify a map name in the shortcode. Example: \{\{&lt; map name="mapname" &gt;\}\}</p>
{{- else -}}
  {{- $mapConfigName := .Get "name" -}}
  {{- $hugoMapsConfig := index site.Params "hugo-maps" -}}
  {{- $mapparams := index $hugoMapsConfig $mapConfigName -}}

  {{- if not $mapparams -}}
<p>Error: Map name {{- $mapConfigName -}} not found in config. Please check your config file.</p>
  {{- else -}}
    {{- $mapname := md5 now.UnixNano -}}
    {{- $baseparams := (resources.Get "default/mapparams.yaml") | unmarshal -}}
    {{- $defaultparams := index $hugoMapsConfig "default" | default dict -}}
    {{- $mapparams = merge $baseparams $defaultparams $mapparams -}}
    {{- $addressZoom := .Get "address-zoom" | default .Page.Params.addressZoom | default ($mapparams.addressZoom | default "") -}}
    
    {{- /* Build geocode query from configured parameters */ -}}
    {{- $geocodeParams := $mapparams.geocodeParams | default "address" -}}
    {{- $mapAddress := "" -}}
    {{- if reflect.IsMap $geocodeParams -}}
      {{- /* If it's a map/dict, use it as-is (shouldn't happen but just in case) */ -}}
      {{- $mapAddress = index $.Page.Params "address" -}}
    {{- else if reflect.IsSlice $geocodeParams -}}
      {{- /* It's an array of parameter names - combine them */ -}}
      {{- $parts := slice -}}
      {{- range $geocodeParams -}}
        {{- $val := index $.Page.Params . -}}
        {{- if $val -}}
          {{- $parts = $parts | append (printf "%v" $val) -}}
        {{- end -}}
      {{- end -}}
      {{- $mapAddress = delimit $parts ", " -}}
    {{- else -}}
      {{- /* It's a string parameter name */ -}}
      {{- $mapAddress = index $.Page.Params (printf "%v" $geocodeParams) -}}
    {{- end -}}
    {{- /* Allow shortcode override */ -}}
    {{- $mapAddress = .Get "address" | default $mapAddress -}}
    {{- $addressZoom := .Get "address-zoom" | default $.Page.Params.addressZoom | default ($mapparams.addressZoom | default "") -}}

    {{- $mapstyle := dict -}}

    {{- if eq ($mapparams.type | default "remote") "remote" -}}
      {{- $sources := dict "sources" ($mapparams.sources | default dict) -}}
      {{- $mapstyle = resources.Get (printf "map-styles/%s.json" ($mapparams.style | default "osm-bright")) | unmarshal -}}
      {{- $mapstyle = merge $mapstyle $sources -}}
    {{- end -}}

    <script src='https://cdn.jsdelivr.net/npm/maplibre-gl@5.17.0/dist/maplibre-gl.js'></script>
    <link href='https://cdn.jsdelivr.net/npm/maplibre-gl@5.17.0/dist/maplibre-gl.css' rel='stylesheet' />

    <style>
      #map-{{ $mapname }} {
        width: {{ .Get "width" | default $mapparams.width }};
        height: {{ .Get "height" | default $mapparams.height }};
        border-radius: inherit;
      }
      
      /* Responsive design - stack on small screens */
      @media (max-width: 768px) {
        #map-{{ $mapname }} {
          height: 250px;
        }
      }
      
      /* Dark mode popup styling */
      @media (prefers-color-scheme: dark) {
        #map-{{ $mapname }} .maplibregl-popup-content {
          background-color: #2a2a2a;
          color: #e0e0e0;
          border: 1px solid #444;
        }
        #map-{{ $mapname }} .maplibregl-popup-tip {
          border-top-color: #2a2a2a;
        }
      }
      
      /* Light mode popup styling */
      @media (prefers-color-scheme: light) {
        #map-{{ $mapname }} .maplibregl-popup-content {
          background-color: #fff;
          color: #333;
          border: 1px solid #ddd;
        }
      }
    </style>

    <div id='map-{{ $mapname }}'></div>

    <script>
      // Setup global helpers if needed
      if (!window.hugoMapsHelpers) {
        window.hugoMapsHelpers = {
          validateLngLat: function(coords) {
            if (!coords) return null;
            if (typeof coords === 'string') {
              try {
                coords = JSON.parse(coords);
              } catch (e) {
                return null;
              }
            }
            if (Array.isArray(coords) && coords.length === 2) {
              const [first, second] = coords;
              if (typeof first === 'number' && typeof second === 'number' && 
                  first >= -180 && first <= 180 && second >= -90 && second <= 90) {
                return coords;
              }
            }
            if (typeof coords === 'object' && coords !== null) {
              let lng = coords.lng || coords.lon;
              let lat = coords.lat;
              if (typeof lng === 'number' && typeof lat === 'number' &&
                  lng >= -180 && lng <= 180 && lat >= -90 && lat <= 90) {
                return [lng, lat];
              }
            }
            return null;
          },

          geocoderApi: {
            // Default configuration - can be overridden per-provider
            defaults: {
              userAgent: 'hugo-maps/1.0',
              timeout: 10000
            },
            
            providers: {
              nominatim: {
                name: 'OpenStreetMap Nominatim',
                forwardGeocode: async function(query, config, defaults) {
                  const providerConfig = (config && config.nominatim) || {};
                  const baseUrl = providerConfig.url || 'https://nominatim.openstreetmap.org';
                  const userAgent = providerConfig.userAgent || defaults.userAgent;
                  const searchQuery = encodeURIComponent(query);
                  const request = `${baseUrl}/search?q=${searchQuery}&format=geojson&polygon_geojson=1&addressdetails=1`;
                  
                  console.log('Nominatim request:', request);
                  
                  const response = await fetch(request, {
                    headers: {
                      'User-Agent': userAgent,
                      'Accept': 'application/json'
                    }
                  });
                  
                  if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
                  
                  const geojson = await response.json();
                  if (!geojson.features || geojson.features.length === 0) {
                    console.warn('No features in Nominatim response');
                    return [];
                  }
                  
                  const features = [];
                  for (const feature of geojson.features) {
                    // Use centroid from geometry or calculate from bbox
                    let center;
                    if (feature.geometry && feature.geometry.type === 'Point') {
                      center = feature.geometry.coordinates;
                    } else if (feature.bbox && feature.bbox.length >= 4) {
                      center = [
                        feature.bbox[0] + (feature.bbox[2] - feature.bbox[0]) / 2,
                        feature.bbox[1] + (feature.bbox[3] - feature.bbox[1]) / 2
                      ];
                    } else if (feature.geometry && feature.geometry.coordinates) {
                      // Try to get first coordinate for polygons
                      const coords = feature.geometry.coordinates;
                      if (Array.isArray(coords) && coords.length > 0) {
                        if (Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                          center = coords[0][0]; // Polygon
                        } else if (Array.isArray(coords[0])) {
                          center = coords[0]; // LineString
                        } else {
                          center = coords; // Point
                        }
                      }
                    }
                    
                    if (!center) {
                      console.warn('Could not determine center for feature:', feature);
                      continue;
                    }
                    
                    features.push({
                      type: 'Feature',
                      geometry: { type: 'Point', coordinates: center },
                      place_name: feature.properties.display_name,
                      properties: feature.properties,
                      text: feature.properties.display_name,
                      place_type: ['place'],
                      center
                    });
                  }
                  
                  console.log('Nominatim returned ' + features.length + ' features');
                  return features;
                }
              },
              
              // Photon is a free alternative geocoder
              photon: {
                name: 'Photon (Komoot)',
                forwardGeocode: async function(query, config, defaults) {
                  const providerConfig = (config && config.photon) || {};
                  const baseUrl = providerConfig.url || 'https://photon.komoot.io';
                  const searchQuery = encodeURIComponent(query);
                  const request = `${baseUrl}/api/?q=${searchQuery}&limit=5`;
                  
                  console.log('Photon request:', request);
                  
                  const response = await fetch(request, {
                    headers: { 'Accept': 'application/json' }
                  });
                  
                  if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
                  
                  const geojson = await response.json();
                  if (!geojson.features || geojson.features.length === 0) {
                    console.warn('No features in Photon response');
                    return [];
                  }
                  
                  const features = geojson.features.map(feature => {
                    const props = feature.properties || {};
                    const placeParts = [props.name, props.city, props.state, props.country].filter(Boolean);
                    const placeName = placeParts.join(', ');
                    return {
                      type: 'Feature',
                      geometry: feature.geometry,
                      place_name: placeName,
                      properties: props,
                      text: props.name || placeName,
                      place_type: [props.osm_value || 'place'],
                      center: feature.geometry.coordinates
                    };
                  });
                  
                  console.log('Photon returned ' + features.length + ' features');
                  return features;
                }
              }
            },
            
            forwardGeocode: async function(config) {
              const providerList = config.providers 
                ? (Array.isArray(config.providers) ? config.providers : config.providers.split(',').map(s => s.trim()))
                : ['photon', 'nominatim'];
              const geocoderConfig = config.config || {};
              
              console.log('forwardGeocode called with providers:', providerList);
              
              for (const providerName of providerList) {
                try {
                  const provider = this.providers[providerName];
                  if (!provider) {
                    console.warn(`Geocoder provider '${providerName}' not found`);
                    continue;
                  }
                  
                  console.log(`Trying provider: ${providerName}`);
                  const results = await provider.forwardGeocode(config.query, geocoderConfig, this.defaults);
                  
                  if (results && results.length > 0) {
                    console.log('Geocoding succeeded with ' + providerName);
                    return { features: results };
                  }
                } catch (e) {
                  console.error(`Geocoder '${providerName}' failed:`, e.message);
                  continue;
                }
              }
              
              console.error('All geocoders failed or returned no results');
              return { features: [] };
            }
          }
        };
      }

      // Immediately initialize this map (IIFE)
      (function() {
        function tryInit() {
          if (typeof maplibregl === 'undefined') {
            setTimeout(tryInit, 50);
            return;
          }

          const mapId = 'map-{{ $mapname }}';
          const container = document.getElementById(mapId);
          if (!container) {
            console.error('Map container not found:', mapId);
            return;
          }

          const center = window.hugoMapsHelpers.validateLngLat({{ $mapparams.center | jsonify }}) || [-0.127758, 51.507351];
          
          const map = new maplibregl.Map({
            container: mapId,
            center: center,
            minZoom: {{ $mapparams.minZoom | default 0 }},
            maxZoom: {{ $mapparams.maxZoom | default 23 }},
            zoom: {{ $mapparams.zoom | default 11 }},
            bearing: {{ $mapparams.bearing | default 0 }},
            minPitch: {{ $mapparams.minPitch | default 0 }},
            maxPitch: {{ $mapparams.maxPitch | default 60 }},
            pitch: {{ $mapparams.pitch | default 0 }},
            antialias: {{ $mapparams.antialias | default false }},
            attributionControl: {{ $mapparams.attributionControl | default true }},
            customAttribution: "{{ $mapparams.customAttribution | default "" }}",
            interactive: {{ $mapparams.interactive | default true }},
            style: {{ $mapstyle | jsonify | safeJS }}
          });

          {{- if $mapparams.navigationControl }}
          map.addControl(new maplibregl.NavigationControl());
          {{- end }}

          {{- if $mapAddress }}
          {{- $geocodersValue := $mapparams.geocoders | default "nominatim" -}}
          const handleGeocode = function() {
            {{- if reflect.IsSlice $geocodersValue }}
            const providers = {{ $geocodersValue | jsonify }};
            {{- else }}
            const providers = "{{ $geocodersValue }}";
            {{- end }}
            window.hugoMapsHelpers.geocoderApi.forwardGeocode({
              query: '{{ $mapAddress }}',
              providers: providers,
              config: {{ $mapparams.geocoderConfig | default dict | jsonify | safeJS }}
            })
              .then((result) => {
                if (result.features && result.features.length > 0) {
                  const feature = result.features[0];
                  {{- if $addressZoom }}
                  const addressZoom = {{ $addressZoom }};
                  {{- else }}
                  const addressZoom = {{ $mapparams.zoom | default 11 }};
                  {{- end }}
                  map.flyTo({
                    center: feature.center,
                    zoom: addressZoom,
                    duration: {{ $mapparams.flyToDuration | default 2500 }},
                    bearing: {{ $mapparams.bearing | default 0 }},
                    pitch: {{ $mapparams.pitch | default 0 }}
                  });
                  // Create a marker at the geocoded location with a popup
                  new maplibregl.Marker()
                    .setLngLat(feature.center)
                    .setPopup(
                      new maplibregl.Popup()
                        .setHTML("<strong>{{ .Page.Title }}</strong>")
                    )
                    .addTo(map)
                    .togglePopup();
                }
              })
              .catch((err) => {
                console.error('Geocode error:', err);
              });
          };
          
          if (map.isStyleLoaded()) {
            handleGeocode();
          } else {
            map.on('load', handleGeocode);
          }
          {{- end }}

          {{- range $mapparams.markers }}
          new maplibregl.Marker()
            .setLngLat(window.hugoMapsHelpers.validateLngLat({{ .location | jsonify }}))
            .setPopup(new maplibregl.Popup().setHTML("{{ .text }}"))
            .addTo(map);
          {{- end }}

          {{- range $mapparams.setfeaturestate }}
          map.on('data', function(e) {
            map.setFeatureState({{ .feature | jsonify }}, {{ .state | jsonify }});
          });
          {{- end }}
        }

        // Trigger on DOM ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', tryInit);
        } else {
          tryInit();
        }
      })();
    </script>
  {{- end -}}
{{- end -}}